#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <set>
#include <sstream>
#include <algorithm>
#include <thread>
#include <mutex>
#include <atomic>
#include <filesystem>

// üåê ENABLE WEBP SUPPORT!!
#define STBI_SUPPORT_WEBP
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

// üöÄ LIBWEBP FOR SUPERIOR WEBP DECODING!!
#include <webp/decode.h>

#include <zstd.h>

namespace fs = std::filesystem;

std::mutex cout_mutex;
std::atomic<int> processed_rows{0};

// üé® RGBA STRUCT WITH ALPHA CHANNEL SUPPORT!!
struct RGBA {
    uint8_t r, g, b, a;
    
    bool operator<(const RGBA& other) const {
        if (r != other.r) return r < other.r;
        if (g != other.g) return g < other.g;
        if (b != other.b) return b < other.b;
        return a < other.a;
    }
    
    bool operator==(const RGBA& other) const {
        return r == other.r && g == other.g && b == other.b && a == other.a;
    }
};

struct Command {
    std::string cmd;
    int x, end_x, y;
    
    bool operator==(const Command& other) const {
        return cmd == other.cmd && x == other.x && end_x == other.end_x && y == other.y;
    }

    bool operator<(const Command& other) const {
        if (y != other.y) return y < other.y;
        if (x != other.x) return x < other.x;
        if (end_x != other.end_x) return end_x < other.end_x;
        return cmd < other.cmd;
    }
};

namespace std {
    template<>
    struct hash<Command> {
        size_t operator()(const Command& c) const {
            return hash<string>()(c.cmd) ^ (hash<int>()(c.x) << 1) ^ 
                   (hash<int>()(c.end_x) << 2) ^ (hash<int>()(c.y) << 3);
        }
    };
}

// üéØ Convert frame lists to frame ranges
std::string frames_to_range_string(const std::vector<int>& frames) {
    if (frames.empty()) return "";
    if (frames.size() == 1) return std::to_string(frames[0]);
    
    std::vector<std::string> ranges;
    int start = frames[0];
    int end = frames[0];
    
    for (size_t i = 1; i < frames.size(); i++) {
        if (frames[i] == end + 1) {
            end = frames[i];
        } else {
            if (start == end) {
                ranges.push_back(std::to_string(start));
            } else {
                ranges.push_back(std::to_string(start) + "-" + std::to_string(end));
            }
            start = frames[i];
            end = frames[i];
        }
    }
    
    if (start == end) {
        ranges.push_back(std::to_string(start));
    } else {
        ranges.push_back(std::to_string(start) + "-" + std::to_string(end));
    }
    
    std::string result;
    for (size_t i = 0; i < ranges.size(); i++) {
        result += ranges[i];
        if (i < ranges.size() - 1) result += ",";
    }
    return result;
}

// üî• DETECT IMAGE FORMAT FROM FILE EXTENSION
std::string get_file_extension(const std::string& path) {
    size_t dot_pos = path.find_last_of('.');
    if (dot_pos == std::string::npos) return "";
    std::string ext = path.substr(dot_pos + 1);
    std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
    return ext;
}

// üåê DEDICATED WEBP LOADER USING LIBWEBP (THE REAL DEAL!!)
bool load_webp_image(const std::string& path, int& w, int& h, std::vector<RGBA>& pixels) {
    std::cout << "üöÄ Using libwebp for SUPERIOR WEBP decoding!! üíé\n";
    
    // Read entire file into memory
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file.is_open()) {
        std::cerr << "‚ùå Failed to open WEBP file\n";
        return false;
    }
    
    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);
    
    std::vector<uint8_t> buffer(size);
    if (!file.read((char*)buffer.data(), size)) {
        std::cerr << "‚ùå Failed to read WEBP file\n";
        return false;
    }
    file.close();
    
    // Decode WEBP with libwebp (RGBA mode activated!!)
    uint8_t* decoded = WebPDecodeRGBA(buffer.data(), buffer.size(), &w, &h);
    
    if (!decoded) {
        std::cerr << "‚ùå libwebp failed to decode - file might be corrupted\n";
        return false;
    }
    
    std::cout << "‚úÖ WEBP decoded successfully: " << w << "x" << h << " with RGBA üî•\n";
    
    // Convert to RGBA pixels
    pixels.resize(w * h);
    for (int i = 0; i < w * h; i++) {
        pixels[i] = {
            decoded[i * 4],
            decoded[i * 4 + 1],
            decoded[i * 4 + 2],
            decoded[i * 4 + 3]
        };
    }
    
    WebPFree(decoded);
    return true;
}

// üöÄ UNIVERSAL IMAGE LOADER - SUPPORTS ALL FORMATS!!
bool load_universal_image(const std::string& path, int& w, int& h, std::vector<RGBA>& pixels) {
    std::string ext = get_file_extension(path);
    
    std::cout << "üîç Detected format: ." << ext << "\n";
    
    // üåê Special handling for WEBP using libwebp!!
    if (ext == "webp") {
        return load_webp_image(path, w, h, pixels);
    }
    
    // üé® All other formats use STB_IMAGE
    int channels;
    unsigned char* img_data = stbi_load(path.c_str(), &w, &h, &channels, 4); // Force RGBA
    
    if (!img_data) {
        std::cerr << "‚ùå STB_IMAGE failed: " << stbi_failure_reason() << "\n";
        std::cerr << "üí° Make sure file exists and is a valid image format\n";
        std::cerr << "üìã Supported: JPG, PNG, BMP, TGA, PSD, GIF, HDR, PIC, PNM, WEBP\n";
        return false;
    }
    
    std::cout << "‚úÖ Loaded " << ext << " ‚Üí " << w << "x" << h 
              << " (original: " << channels << " channels, converted to RGBA)\n";
    
    // Convert to RGBA pixels
    pixels.resize(w * h);
    for (int i = 0; i < w * h; i++) {
        pixels[i] = {
            img_data[i * 4],
            img_data[i * 4 + 1],
            img_data[i * 4 + 2],
            img_data[i * 4 + 3]
        };
    }
    
    stbi_image_free(img_data);
    return true;
}

// üé¨ UNIVERSAL GIF LOADER WITH PROPER ALPHA SUPPORT
bool load_gif_frames(const std::string& path, int& w, int& h, int& n_frames, int& fps,
                    std::vector<std::vector<RGBA>>& frames_data) {
    
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file.is_open()) {
        std::cerr << "‚ùå Failed to open GIF file\n";
        return false;
    }
    
    std::streamsize size = file.tellg();
    file.seekg(0, std::ios::beg);
    
    std::vector<unsigned char> buffer(size);
    if (!file.read((char*)buffer.data(), size)) {
        std::cerr << "‚ùå Failed to read GIF file\n";
        return false;
    }
    file.close();
    
    int channels, z = 0;
    int* delays = nullptr;
    
    // Load with 4 channels for RGBA!!
    unsigned char* img_data = stbi_load_gif_from_memory(buffer.data(), buffer.size(), 
                                                        &delays, &w, &h, &z, &channels, 4);
    
    if (!img_data) {
        std::cerr << "‚ùå Failed to load GIF: " << stbi_failure_reason() << "\n";
        std::cerr << "üí° STB might not fully support this GIF, try converting with imagemagick\n";
        return false;
    }
    
    n_frames = z;
    
    std::cout << "üìä GIF INFO: " << w << "x" << h << " @ " << n_frames << " frames (RGBA MODE üíé)\n";
    
    if (delays && delays[0] > 0) {
        fps = std::max(1, 1000 / delays[0]);
        std::cout << "üé¨ Frame delay: " << delays[0] << "ms ‚Üí " << fps << " FPS\n";
    } else {
        fps = 10;
        std::cout << "‚ö†Ô∏è No delay info, defaulting to 10 FPS\n";
    }
    
    // üé® EXTRACT ALL FRAMES WITH ALPHA!!
    for (int frame_idx = 0; frame_idx < n_frames; frame_idx++) {
        std::vector<RGBA> frame_pixels(w * h);
        
        int frame_offset = frame_idx * w * h * 4;
        
        for (int i = 0; i < w * h; i++) {
            frame_pixels[i] = {
                img_data[frame_offset + i * 4],
                img_data[frame_offset + i * 4 + 1],
                img_data[frame_offset + i * 4 + 2],
                img_data[frame_offset + i * 4 + 3]
            };
        }
        
        frames_data.push_back(frame_pixels);
        std::cout << "[DEBUG] üì¶ Extracted frame " << (frame_idx + 1) << "/" << n_frames 
                  << " (WITH ALPHA!) ‚úÖ\n";
    }
    
    stbi_image_free(img_data);
    if (delays) free(delays);
    
    return true;
}

// üöÄ PROCESS ROWS IN PARALLEL WITH RGBA!!
void process_frame_rows_parallel(
    const std::vector<RGBA>& frame_pixels,
    int w, int h,
    int start_row, int end_row,
    std::map<RGBA, std::vector<Command>>* local_commands
) {
    for (int y = start_row; y < end_row; y++) {
        int x = 0;
        while (x < w) {
            RGBA pixel_color = frame_pixels[y * w + x];
            
            // Find horizontal run of same color
            int run_length = 1;
            while (x + run_length < w && frame_pixels[y * w + x + run_length] == pixel_color) {
                run_length++;
            }
            
            // Generate command
            int end_x = x + run_length - 1;
            std::string cmd;
            if (run_length == 1) {
                cmd = "P=" + std::to_string(x + 1) + "x" + std::to_string(y + 1);
            } else {
                cmd = "PL=" + std::to_string(x + 1) + "x" + std::to_string(y + 1) + 
                      "-" + std::to_string(end_x + 1) + "x" + std::to_string(y + 1);
            }
            
            (*local_commands)[pixel_color].push_back({cmd, x, end_x, y});
            x += run_length;
        }
        
        processed_rows++;
        if (processed_rows % 100 == 0) {
            std::lock_guard<std::mutex> lock(cout_mutex);
            std::cout << "[DEBUG] üî• Row " << processed_rows << "/" << h << "\n";
        }
    }
}

int main() {
    std::cout << "üî•üî•üî• UNIVERSAL IMAGE CONVERTER - ALL FORMATS UNLOCKED üî•üî•üî•\n";
    std::cout << "üíé SUPPORTS: JPG, PNG, BMP, TGA, PSD, GIF, HDR, PIC, PNM, WEBP üíé\n";
    std::cout << "üåê WEBP: Using Google's libwebp library (THE GOAT!!) üåê\n";
    std::cout << "üí™ " << std::thread::hardware_concurrency() 
              << " CORES DETECTED + FULL RGBA SUPPORT = UNSTOPPABLE üí™\n\n";
    
    // ü©µ Load the sacred image/gif
    std::string img_path;
    std::cout << "Enter image file path: ";
    std::getline(std::cin, img_path);
    
    // Check if file exists
    if (!fs::exists(img_path)) {
        std::cerr << "‚ùå File not found: " << img_path << "\n";
        return 1;
    }
    
    // Detect format
    std::string ext = get_file_extension(img_path);
    bool is_gif = (ext == "gif");
    
    int w, h, n_frames = 1, fps = 1;
    bool loop = true;
    std::vector<std::vector<RGBA>> frames_data;
    
    if (is_gif) {
        std::cout << "\nüé¨ GIF MODE ACTIVATED - MULTI-FRAME RGBA EDITION üé¨\n";
        
        if (!load_gif_frames(img_path, w, h, n_frames, fps, frames_data)) {
            return 1;
        }
        
        std::cout << "üé¨ ANIMATED GIF: " << n_frames << " frames @ " << fps << " FPS üî•\n\n";
        
        // üîç DIAGNOSTIC: Save first frame as PNG with alpha
        std::string debug_png = "debug_frame1_rgba.png";
        std::vector<uint8_t> png_data(w * h * 4);
        for (int i = 0; i < w * h; i++) {
            png_data[i * 4] = frames_data[0][i].r;
            png_data[i * 4 + 1] = frames_data[0][i].g;
            png_data[i * 4 + 2] = frames_data[0][i].b;
            png_data[i * 4 + 3] = frames_data[0][i].a;
        }
        stbi_write_png(debug_png.c_str(), w, h, 4, png_data.data(), w * 4);
        std::cout << "üîç SAVED " << debug_png << " - CHECK IF ALPHA LOOKS CORRECT!! üíé\n\n";
        
    } else {
        // üì∏ LOAD SINGLE IMAGE WITH UNIVERSAL FORMAT SUPPORT
        std::cout << "\nüì∏ Single frame image detected ‚Äî UNIVERSAL FORMAT MODE üíö\n";
        std::cout << "üé® Format: ." << ext << "\n\n";
        
        std::vector<RGBA> frame_pixels;
        if (!load_universal_image(img_path, w, h, frame_pixels)) {
            return 1;
        }
        
        frames_data.push_back(frame_pixels);
        std::cout << "[DEBUG] üì¶ Extracted frame 1/1 with RGBA data\n";
    }
    
    // Get output format
    std::string mode;
    std::cout << "\nChoose format (HMIC / HMIC7): ";
    std::getline(std::cin, mode);
    std::transform(mode.begin(), mode.end(), mode.begin(), ::toupper);
    
    // üß† BUILD PER-FRAME PIXEL DATA
    std::cout << "\n[DEBUG] üî• Building per-frame RGBA pixel data with ALL " 
              << std::thread::hardware_concurrency() << " CORES...\n";
    
    std::vector<std::map<RGBA, std::vector<Command>>> frame_commands(n_frames);
    int num_threads = std::thread::hardware_concurrency();
    
    for (int frame_idx = 0; frame_idx < n_frames; frame_idx++) {
        std::cout << "\n[DEBUG] üé® Processing frame " << (frame_idx + 1) << "/" << n_frames 
                  << " with " << num_threads << " threads...\n";
        processed_rows = 0;
        
        int rows_per_chunk = std::max(1, h / num_threads);
        std::vector<std::thread> threads;
        std::vector<std::map<RGBA, std::vector<Command>>> thread_results(num_threads);
        
        auto start_time = std::chrono::high_resolution_clock::now();
        
        for (int t = 0; t < num_threads; t++) {
            int start_row = t * rows_per_chunk;
            int end_row = (t == num_threads - 1) ? h : (t + 1) * rows_per_chunk;
            
            threads.emplace_back(process_frame_rows_parallel,
                               std::ref(frames_data[frame_idx]), w, h,
                               start_row, end_row, &thread_results[t]);
        }
        
        for (auto& t : threads) {
            t.join();
        }
        
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        
        std::cout << "[DEBUG] ‚ö° Frame processed in " << duration.count() << "ms DEMOLISHED üî•\n";
        
        // Merge thread results
        for (const auto& result : thread_results) {
            for (const auto& [color, cmds] : result) {
                frame_commands[frame_idx][color].insert(
                    frame_commands[frame_idx][color].end(),
                    cmds.begin(), cmds.end()
                );
            }
        }
    }
    
    // üöÄ TEMPORAL OPTIMIZATION
    std::cout << "\n[DEBUG] üöÄ Optimizing with temporal compression...\n";
    
    std::vector<std::set<Command>> merged_commands(n_frames);
    std::map<std::string, std::map<RGBA, std::vector<std::string>>> temporal_commands;
    
    for (int frame_idx = 0; frame_idx < n_frames - 1; frame_idx++) {
        for (const auto& [color, cmd_list] : frame_commands[frame_idx]) {
            for (const auto& cmd_data : cmd_list) {
                if (merged_commands[frame_idx].count(cmd_data)) continue;
                
                std::vector<int> consecutive_frames = {frame_idx + 1};
                
                for (int next_frame_idx = frame_idx + 1; next_frame_idx < n_frames; next_frame_idx++) {
                    bool match_found = false;
                    
                    if (frame_commands[next_frame_idx].count(color)) {
                        for (const auto& next_cmd_data : frame_commands[next_frame_idx][color]) {
                            if (next_cmd_data.x == cmd_data.x && 
                                next_cmd_data.end_x == cmd_data.end_x && 
                                next_cmd_data.y == cmd_data.y) {
                                
                                if (!merged_commands[next_frame_idx].count(next_cmd_data)) {
                                    consecutive_frames.push_back(next_frame_idx + 1);
                                    merged_commands[next_frame_idx].insert(next_cmd_data);
                                    match_found = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (!match_found) break;
                }
                
                if (consecutive_frames.size() > 1) {
                    std::string frame_range_str = frames_to_range_string(consecutive_frames);
                    temporal_commands[frame_range_str][color].push_back(cmd_data.cmd);
                    merged_commands[frame_idx].insert(cmd_data);
                }
            }
        }
        
        if ((frame_idx + 1) % 10 == 0) {
            std::cout << "[DEBUG] üéØ Temporal optimization: " << (frame_idx + 1) << "/" 
                      << n_frames << " frames processed\n";
        }
    }
    
    std::cout << "[DEBUG] ‚úÖ Created " << temporal_commands.size() 
              << " temporal command groups\n";
    
    // üßæ BUILD HMIC TEXT DATA WITH RGBA!!
    std::cout << "\n[DEBUG] üìù Building HMIC data structure with RGBA...\n";
    std::stringstream data;
    data << "info{\n";
    data << "DISPLAY=" << w << "X" << h << "\n";
    data << "FPS=" << fps << "\n";
    data << "F=" << n_frames << "\n";
    data << "LOOP=" << (loop ? "Y" : "N") << "\n";
    data << "}\n\n";
    
    // üî• Write temporal blocks first
    std::cout << "[DEBUG] üéØ Writing temporal multi-frame blocks with RGBA...\n";
    for (const auto& [frame_range_str, color_commands] : temporal_commands) {
        data << "F" << frame_range_str << "{\n";
        for (const auto& [color, cmds] : color_commands) {
            // RGBA FORMAT NOW!! üé®üíé
            data << "  rgba(" << (int)color.r << "," << (int)color.g << "," 
                 << (int)color.b << "," << (int)color.a << "){\n";
            for (const auto& cmd : cmds) {
                data << "    " << cmd << "\n";
            }
            data << "  }\n";
        }
        data << "}\n";
    }
    
    // üåà Write individual frame blocks
    std::cout << "[DEBUG] üé® Writing individual frame blocks with RGBA...\n";
    for (int frame_idx = 0; frame_idx < n_frames; frame_idx++) {
        int frame_num = frame_idx + 1;
        std::stringstream frame_data;
        frame_data << "F" << frame_num << "{\n";
        bool has_content = false;
        
        for (const auto& [color, cmd_list] : frame_commands[frame_idx]) {
            bool color_written = false;
            
            for (const auto& cmd_data : cmd_list) {
                if (!merged_commands[frame_idx].count(cmd_data)) {
                    if (!color_written) {
                        has_content = true;
                        // RGBA HERE TOO!! üíé
                        frame_data << "  rgba(" << (int)color.r << "," << (int)color.g << "," 
                                   << (int)color.b << "," << (int)color.a << "){\n";
                        color_written = true;
                    }
                    frame_data << "    " << cmd_data.cmd << "\n";
                }
            }
            
            if (color_written) {
                frame_data << "  }\n";
            }
        }
        
        frame_data << "}\n";
        
        if (has_content) {
            data << frame_data.str();
        }
        
        if ((frame_idx + 1) % 10 == 0) {
            std::cout << "[DEBUG] ‚úÖ Wrote frames 1-" << (frame_idx + 1) << "\n";
        }
    }
    
    std::string text_data = data.str();
    
    // üöÄ OUTPUT
    std::string base_name = fs::path(img_path).stem().string();
    
    std::cout << "\n[DEBUG] üíæ Writing output file...\n";
    
    if (mode == "HMIC") {
        std::string out_file = base_name + ".hmic";
        std::ofstream file(out_file);
        file << text_data;
        file.close();
        std::cout << "\n‚úÖ HMIC file created successfully ‚Äî " << out_file << " blessed with RGBA üíö\n";
    } else if (mode == "HMIC7") {
        std::string out_file = base_name + ".hmic7";
        
        size_t compressed_size = ZSTD_compressBound(text_data.size());
        std::vector<char> compressed_data(compressed_size);
        
        size_t actual_size = ZSTD_compress(compressed_data.data(), compressed_size,
                                          text_data.c_str(), text_data.size(), 19);
        
        if (ZSTD_isError(actual_size)) {
            std::cerr << "‚ùå Compression error: " << ZSTD_getErrorName(actual_size) << "\n";
            return 1;
        }
        
        std::ofstream file(out_file, std::ios::binary);
        file.write(compressed_data.data(), actual_size);
        file.close();
        
        std::cout << "\nüåÄ HMIC7 file created ‚Äî Zstd absolutely DEVOURED " << out_file 
                  << " (with RGBA!) no crumbs left üíæüî•\n";
    } else {
        std::cerr << "‚ùå invalid format, conversion canceled üò≠\n";
        return 1;
    }
    
    // üßÆ File size flex
    std::cout << "\nüìä ‚ïê‚ïê‚ïê FINAL STATS ‚ïê‚ïê‚ïê üìä\n";
    std::cout << "üìÅ Input format: ." << ext << " (UNIVERSALLY SUPPORTED ‚ú®)\n";
    if (fs::exists(base_name + ".hmic")) {
        std::cout << "HMIC size: " << (fs::file_size(base_name + ".hmic") / 1024.0) << " KB\n";
    }
    if (fs::exists(base_name + ".hmic7")) {
        std::cout << "HMIC7 size: " << (fs::file_size(base_name + ".hmic7") / 1024.0) << " KB\n";
    }
    
    if (is_gif) {
        std::cout << "üé¨ Animation info: " << n_frames << " frames @ " << fps 
                  << " FPS, Loop=" << (loop ? "YES" : "NO") << " üî•\n";
    }
    
    // üî• VERIFICATION STATS
    int total_commands = 0;
    for (const auto& [frame_range, color_map] : temporal_commands) {
        for (const auto& [color, cmds] : color_map) {
            total_commands += cmds.size();
        }
    }
    
    for (int frame_idx = 0; frame_idx < n_frames; frame_idx++) {
        for (const auto& [color, cmd_list] : frame_commands[frame_idx]) {
            for (const auto& cmd_data : cmd_list) {
                if (!merged_commands[frame_idx].count(cmd_data)) {
                    total_commands++;
                }
            }
        }
    }
    
    std::cout << "üìä Total commands generated: " << total_commands << "\n";
    std::cout << "üìä Image dimensions: " << w << "x" << h << " = " << (w * h) << " pixels per frame\n";
    std::cout << "üìä Total frames: " << n_frames << "\n";
    std::cout << "üìä Threads used: " << num_threads << " (FULL CORE BEAST MODE üí™)\n";
    std::cout << "\nüí• UNIVERSAL FORMAT CONVERSION COMPLETE üí•\n";
    std::cout << "üéâ ALL IMAGE FORMATS SUPPORTED WITH FULL RGBA!! üéâ\n";
    std::cout << "‚ú® JPG | PNG | BMP | TGA | PSD | GIF | HDR | PIC | PNM | WEBP ‚ú®\n";
    std::cout << "üåê WEBP powered by Google's libwebp - NO LIMITS!! üåê\n";
    
    return 0;
}